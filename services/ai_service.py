import os
import requests
import base64
import logging
from services.weather_service import check_rain_forecast
from services.huggingface_vision import analyze_plant_with_huggingface

logger = logging.getLogger(__name__)

def format_farmer_response(ai_response):
    """Format AI response for better farmer readability"""
    try:
        # This function is now simplified since diagnosis extraction is handled in analyze_plant_image
        formatted_treatment = format_treatment_text(ai_response)
        return {
            'diagnosis': "üîç ‡§™‡•å‡§ß‡•á ‡§ï‡§æ ‡§µ‡§ø‡§∂‡•ç‡§≤‡•á‡§∑‡§£ ‡§™‡•Ç‡§∞‡§æ (Plant Analysis Complete)",
            'treatment': formatted_treatment
        }
        
    except Exception as e:
        logger.error(f"Error formatting farmer response: {str(e)}")
        return {
            'diagnosis': "üîç ‡§™‡•å‡§ß‡•á ‡§ï‡§æ ‡§µ‡§ø‡§∂‡•ç‡§≤‡•á‡§∑‡§£ ‡§™‡•Ç‡§∞‡§æ (Plant Analysis Complete)",
            'treatment': ai_response
        }

def format_treatment_text(text):
    """Format treatment text with better structure and emojis"""
    try:
        # Split into sections and add proper formatting
        sections = text.split('\n\n')
        formatted_sections = []
        
        for section in sections:
            if not section.strip():
                continue
                
            # Add emojis based on content
            if any(keyword in section.lower() for keyword in ['organic', '‡§ú‡•à‡§µ‡§ø‡§ï', 'neem', '‡§®‡•Ä‡§Æ']):
                if not section.startswith('üåø'):
                    section = f"üåø **‡§ú‡•à‡§µ‡§ø‡§ï ‡§â‡§™‡§ö‡§æ‡§∞ (Organic Treatment):**\n{section}"
            elif any(keyword in section.lower() for keyword in ['chemical', '‡§∞‡§æ‡§∏‡§æ‡§Ø‡§®‡§ø‡§ï', 'pesticide', 'fungicide']):
                if not section.startswith('üíä'):
                    section = f"üíä **‡§∞‡§æ‡§∏‡§æ‡§Ø‡§®‡§ø‡§ï ‡§â‡§™‡§ö‡§æ‡§∞ (Chemical Treatment):**\n{section}"
            elif any(keyword in section.lower() for keyword in ['prevention', '‡§∞‡•ã‡§ï‡§•‡§æ‡§Æ', 'avoid', '‡§¨‡§ö‡§æ‡§µ']):
                if not section.startswith('üõ°Ô∏è'):
                    section = f"üõ°Ô∏è **‡§∞‡•ã‡§ï‡§•‡§æ‡§Æ (Prevention):**\n{section}"
            elif any(keyword in section.lower() for keyword in ['timing', 'time', '‡§∏‡§Æ‡§Ø', 'when']):
                if not section.startswith('‚è∞'):
                    section = f"‚è∞ **‡§∏‡§π‡•Ä ‡§∏‡§Æ‡§Ø (Best Timing):**\n{section}"
            elif any(keyword in section.lower() for keyword in ['cost', 'price', '‡§≤‡§æ‡§ó‡§§', '‡§ñ‡§∞‡•ç‡§ö']):
                if not section.startswith('üí∞'):
                    section = f"üí∞ **‡§≤‡§æ‡§ó‡§§ (Cost Information):**\n{section}"
            elif any(keyword in section.lower() for keyword in ['disease', 'pest', '‡§∞‡•ã‡§ó', '‡§ï‡•Ä‡§ü']):
                if not section.startswith('üîç'):
                    section = f"üîç **‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ ‡§ï‡•Ä ‡§™‡§π‡§ö‡§æ‡§® (Problem Identification):**\n{section}"
            
            formatted_sections.append(section.strip())
        
        # Join sections with proper spacing
        formatted = '\n\n'.join(formatted_sections)
        
        # Add final note if no cost information
        if not any(keyword in formatted.lower() for keyword in ['cost', '‡§≤‡§æ‡§ó‡§§', '‡§ñ‡§∞‡•ç‡§ö']):
            formatted += "\n\nüí∞ **‡§≤‡§æ‡§ó‡§§ ‡§ï‡•Ä ‡§ú‡§æ‡§®‡§ï‡§æ‡§∞‡•Ä:** ‡§∏‡•ç‡§•‡§æ‡§®‡•Ä‡§Ø ‡§ï‡•É‡§∑‡§ø ‡§µ‡§ø‡§∂‡•á‡§∑‡§ú‡•ç‡§û ‡§∏‡•á ‡§∏‡§Ç‡§™‡§∞‡•ç‡§ï ‡§ï‡§∞‡•á‡§Ç‡•§"
        
        return formatted.strip()
        
    except Exception as e:
        logger.error(f"Error formatting treatment text: {str(e)}")
        return text

def analyze_plant_image(image_path, weather_data=None):
    """Analyze plant image using Gemini Vision API as primary method"""
    
    # Use Gemini Vision API as primary method
    gemini_key = os.getenv('GEMINI_API_KEY', 'AIzaSyCVchsFQ9RyH4wdM2qrVZqRBJyQ5g9qOKg')
    
    try:
        # Read and encode image
        with open(image_path, 'rb') as image_file:
            image_data = base64.b64encode(image_file.read()).decode('utf-8')
        
        # Detect image format
        from PIL import Image
        img = Image.open(image_path)
        img_format = img.format.lower()
        mime_type = f"image/{img_format}" if img_format in ['jpeg', 'jpg', 'png', 'webp'] else "image/jpeg"
        
        # Clean Hindi-only structured prompt
        prompt = """‡§á‡§∏ ‡§™‡•å‡§ß‡•á ‡§ï‡•Ä ‡§§‡§∏‡•ç‡§µ‡•Ä‡§∞ ‡§ï‡§æ ‡§µ‡§ø‡§∂‡•ç‡§≤‡•á‡§∑‡§£ ‡§ï‡§∞‡•á‡§Ç ‡§î‡§∞ ‡§¨‡§ø‡§≤‡•ç‡§ï‡•Å‡§≤ ‡§á‡§∏‡•Ä ‡§´‡•â‡§∞‡•ç‡§Æ‡•á‡§ü ‡§Æ‡•á‡§Ç ‡§ú‡§µ‡§æ‡§¨ ‡§¶‡•á‡§Ç:

üîç **‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ ‡§ï‡•Ä ‡§™‡§π‡§ö‡§æ‡§®:**
‡§ï‡•Ä‡§ü ‡§ï‡•á ‡§Ö‡§Ç‡§°‡•á ‡§Ø‡§æ ‡§∏‡§´‡•á‡§¶ ‡§Æ‡§ï‡•ç‡§ñ‡•Ä ‡§ï‡•Ä ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ ‡§¶‡§ø‡§ñ ‡§∞‡§π‡•Ä ‡§π‡•à

üåø **‡§ú‡•à‡§µ‡§ø‡§ï ‡§â‡§™‡§ö‡§æ‡§∞:**
‚Ä¢ ‡§®‡•Ä‡§Æ ‡§ï‡§æ ‡§§‡•á‡§≤: 10 ‡§Æ‡§ø‡§≤‡•Ä ‡§™‡•ç‡§∞‡§§‡§ø ‡§≤‡•Ä‡§ü‡§∞ ‡§™‡§æ‡§®‡•Ä ‡§Æ‡•á‡§Ç ‡§Æ‡§ø‡§≤‡§æ‡§ï‡§∞ ‡§õ‡§ø‡§°‡§º‡§ï‡§æ‡§µ ‡§ï‡§∞‡•á‡§Ç
‚Ä¢ ‡§ó‡•ã‡§¨‡§∞ ‡§ï‡§æ ‡§ò‡•ã‡§≤: 1 ‡§ï‡§ø‡§≤‡•ã ‡§ó‡•ã‡§¨‡§∞ ‡§ï‡•ã 10 ‡§≤‡•Ä‡§ü‡§∞ ‡§™‡§æ‡§®‡•Ä ‡§Æ‡•á‡§Ç ‡§ò‡•ã‡§≤‡§ï‡§∞ ‡§õ‡§æ‡§®‡•á‡§Ç
‚Ä¢ ‡§π‡§∞‡•Ä ‡§™‡§§‡•ç‡§§‡§ø‡§Ø‡•ã‡§Ç ‡§ï‡§æ ‡§ï‡§æ‡§¢‡§º‡§æ: ‡§®‡•Ä‡§Æ, ‡§§‡•Å‡§≤‡§∏‡•Ä ‡§ï‡•Ä ‡§™‡§§‡•ç‡§§‡§ø‡§Ø‡§æ‡§Ç ‡§â‡§¨‡§æ‡§≤‡§ï‡§∞ ‡§õ‡§ø‡§°‡§º‡§ï‡§æ‡§µ ‡§ï‡§∞‡•á‡§Ç

üíä **‡§∞‡§æ‡§∏‡§æ‡§Ø‡§®‡§ø‡§ï ‡§â‡§™‡§ö‡§æ‡§∞:**
‚Ä¢ ‡§á‡§Æ‡§ø‡§°‡§æ‡§ï‡•ç‡§≤‡•ã‡§™‡•ç‡§∞‡§ø‡§°: ‡§≤‡•á‡§¨‡§≤ ‡§ï‡•á ‡§Ö‡§®‡•Å‡§∏‡§æ‡§∞ ‡§Æ‡§æ‡§§‡•ç‡§∞‡§æ ‡§ï‡§æ ‡§™‡•ç‡§∞‡§Ø‡•ã‡§ó ‡§ï‡§∞‡•á‡§Ç
‚Ä¢ ‡§ï‡•ç‡§≤‡•ã‡§∞‡•ã‡§™‡§æ‡§Ø‡§∞‡§ø‡§´‡•â‡§∏: ‡§≠‡§æ‡§∞‡§§ ‡§Æ‡•á‡§Ç ‡§â‡§™‡§≤‡§¨‡•ç‡§ß ‡§π‡•à
‚Ä¢ ‡§∏‡•ç‡§•‡§æ‡§®‡•Ä‡§Ø ‡§ï‡•É‡§∑‡§ø ‡§¶‡•Å‡§ï‡§æ‡§® ‡§∏‡•á ‡§∏‡§≤‡§æ‡§π ‡§≤‡•á‡§Ç

‚è∞ **‡§∏‡§π‡•Ä ‡§∏‡§Æ‡§Ø:**
‚Ä¢ ‡§∏‡•Å‡§¨‡§π ‡§ú‡§≤‡•ç‡§¶‡•Ä ‡§Ø‡§æ ‡§∂‡§æ‡§Æ ‡§ï‡•á ‡§∏‡§Æ‡§Ø ‡§õ‡§ø‡§°‡§º‡§ï‡§æ‡§µ ‡§ï‡§∞‡•á‡§Ç
‚Ä¢ ‡§ß‡•Ç‡§™ ‡§§‡•á‡§ú ‡§® ‡§π‡•ã ‡§§‡§¨ ‡§ï‡§∞‡•á‡§Ç
‚Ä¢ ‡§¨‡§æ‡§∞‡§ø‡§∂ ‡§∏‡•á ‡§™‡§π‡§≤‡•á ‡§® ‡§ï‡§∞‡•á‡§Ç

üõ°Ô∏è **‡§∞‡•ã‡§ï‡§•‡§æ‡§Æ:**
‚Ä¢ ‡§´‡§∏‡§≤ ‡§ö‡§ï‡•ç‡§∞ ‡§Ö‡§™‡§®‡§æ‡§è‡§Ç
‚Ä¢ ‡§ñ‡§∞‡§™‡§§‡§µ‡§æ‡§∞ ‡§®‡§ø‡§Ø‡§Ç‡§§‡•ç‡§∞‡§£ ‡§ï‡§∞‡•á‡§Ç
‚Ä¢ ‡§ñ‡•á‡§§ ‡§ï‡•Ä ‡§∏‡§´‡§æ‡§à ‡§∞‡§ñ‡•á‡§Ç
‚Ä¢ ‡§®‡§ø‡§Ø‡§Æ‡§ø‡§§ ‡§®‡§ø‡§ó‡§∞‡§æ‡§®‡•Ä ‡§ï‡§∞‡•á‡§Ç

üí∞ **‡§≤‡§æ‡§ó‡§§:**
‚Ä¢ ‡§Ö‡§®‡•Å‡§Æ‡§æ‡§®‡§ø‡§§ ‡§ñ‡§∞‡•ç‡§ö: ‚Çπ500-1000 ‡§™‡•ç‡§∞‡§§‡§ø ‡§è‡§ï‡§°‡§º
‚Ä¢ ‡§ú‡•à‡§µ‡§ø‡§ï ‡§â‡§™‡§ö‡§æ‡§∞ ‡§∏‡§∏‡•ç‡§§‡§æ ‡§π‡•à

‡§∏‡§ø‡§∞‡•ç‡§´ ‡§π‡§ø‡§Ç‡§¶‡•Ä ‡§Æ‡•á‡§Ç ‡§∏‡§∞‡§≤ ‡§≠‡§æ‡§∑‡§æ ‡§Æ‡•á‡§Ç ‡§ú‡§µ‡§æ‡§¨ ‡§¶‡•á‡§Ç‡•§"""
        
        # Use Gemini 1.5 Flash Vision API
        url = f"https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key={gemini_key}"
        headers = {"Content-Type": "application/json"}
        
        data = {
            "contents": [{
                "parts": [
                    {"text": prompt},
                    {
                        "inline_data": {
                            "mime_type": mime_type,
                            "data": image_data
                        }
                    }
                ]
            }]
        }
        
        response = requests.post(url, json=data, headers=headers, timeout=30)
        
        if response.status_code == 200:
            result = response.json()
            
            if 'candidates' in result and len(result['candidates']) > 0:
                candidate = result['candidates'][0]
                
                if 'content' in candidate and 'parts' in candidate['content']:
                    ai_response = candidate['content']['parts'][0]['text']
                    
                    # Extract diagnosis - look for content after problem identification
                    lines = ai_response.split('\n')
                    diagnosis = ""
                    treatment = ai_response
                    
                    # Find the line after problem identification header
                    for i, line in enumerate(lines):
                        if 'üîç' in line and ('‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ' in line or '‡§™‡§π‡§ö‡§æ‡§®' in line):
                            # Get the next non-empty line as diagnosis
                            for j in range(i+1, len(lines)):
                                next_line = lines[j].strip()
                                if next_line and not next_line.startswith('üîç') and not next_line.startswith('**'):
                                    diagnosis = next_line
                                    break
                            break
                    
                    # Fallback: look for any meaningful content about pest/disease
                    if not diagnosis:
                        for line in lines:
                            line_clean = line.strip()
                            if ('‡§ï‡•Ä‡§°‡§º' in line_clean or '‡§ï‡•Ä‡§ü' in line_clean or '‡§∞‡•ã‡§ó' in line_clean or '‡§¨‡•Ä‡§Æ‡§æ‡§∞‡•Ä' in line_clean) and len(line_clean) > 20:
                                diagnosis = line_clean
                                break
                    
                    # Final fallback
                    if not diagnosis:
                        diagnosis = "üîç ‡§™‡•å‡§ß‡•á ‡§ï‡§æ ‡§µ‡§ø‡§∂‡•ç‡§≤‡•á‡§∑‡§£ ‡§™‡•Ç‡§∞‡§æ (Plant Analysis Complete)"
                    
                    return {
                        'diagnosis': diagnosis,
                        'treatment': treatment,
                        'confidence': '‡§â‡§ö‡•ç‡§ö (High)',
                        'model': 'Gemini 1.5 Flash Vision'
                    }
                else:
                    return get_fallback_analysis()
            else:
                return get_fallback_analysis()
        else:
            logger.error(f"Gemini API error: {response.status_code} - {response.text}")
            
            if response.status_code == 429:
                return {
                    'diagnosis': "API quota exceeded",
                    'treatment': "Gemini API quota limit reached. Please wait or try again later.",
                    'error': 'Gemini API quota exceeded'
                }
            return get_fallback_analysis()
            
    except Exception as e:
        logger.error(f"Gemini Vision API failed: {str(e)}")
        return get_fallback_analysis()

    # Fallback to Hugging Face if Gemini fails
    try:
        result = analyze_plant_with_huggingface(image_path)
        if not result.get('error'):
            if weather_data:
                has_rain, rain_message = check_rain_forecast(weather_data)
                if has_rain:
                    result['weather_warning'] = f"‚ö†Ô∏è Weather Alert: {rain_message}. Avoid spraying treatments before rain."
            return result
    except Exception as e:
        logger.warning(f"Hugging Face fallback failed: {str(e)}")

    # Final fallback
    return get_ai_error()

def parse_ai_response(ai_response):
    """Parse AI response into structured format"""
    try:
        # Split response into sections
        sections = ai_response.split('\n\n')
        
        diagnosis = ""
        treatment = ""
        
        # Extract diagnosis (usually in first section)
        for section in sections:
            if any(keyword in section.lower() for keyword in ['disease', 'pest', 'identification', 'diagnosis']):
                diagnosis = section.strip()
                break
        
        if not diagnosis and sections:
            diagnosis = sections[0].strip()
        
        # Extract treatment advice (combine organic and chemical sections)
        treatment_sections = []
        for section in sections:
            if any(keyword in section.lower() for keyword in ['treatment', 'organic', 'chemical', 'remedy', 'control']):
                treatment_sections.append(section.strip())
        
        treatment = '\n\n'.join(treatment_sections) if treatment_sections else ai_response
        
        return {
            'diagnosis': diagnosis or "Analysis completed - see treatment recommendations",
            'treatment': treatment or ai_response,
            'confidence': 'High'  # Default confidence
        }
        
    except Exception as e:
        logger.error(f"Error parsing AI response: {str(e)}")
        return {
            'diagnosis': "Plant health analysis completed",
            'treatment': ai_response,
            'confidence': 'Medium'
        }

def process_contextual_query(query, language, user_crops, pin_code, scan_result=None, weather_data=None, market_data=None):
    """Enhanced contextual query processing with comprehensive context awareness"""
    
    try:
        from services.enhanced_voice_assistant import enhanced_voice_assistant
        
        # Use enhanced voice assistant for better contextual responses
        response = enhanced_voice_assistant.process_contextual_query(
            query=query,
            language=language,
            user_crops=user_crops,
            pin_code=pin_code,
            scan_result=scan_result,
            weather_data=weather_data,
            market_data=market_data
        )
        
        return response
        
    except Exception as e:
        logger.error(f"Enhanced contextual query error: {str(e)}")
        
        # Fallback to original implementation
        try:
            gemini_key = os.getenv('GEMINI_API_KEY', 'AIzaSyCVchsFQ9RyH4wdM2qrVZqRBJyQ5g9qOKg')
            url = f"https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key={gemini_key}"
            headers = {"Content-Type": "application/json"}
            
            # Build context from scan result
            context = ""
            if scan_result and scan_result.get('diagnosis'):
                context = f"‡§™‡•å‡§ß‡•á ‡§ï‡•Ä ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ: {scan_result.get('diagnosis', '')}\n‡§∏‡•Å‡§ù‡§æ‡§Ø‡§æ ‡§ó‡§Ø‡§æ ‡§á‡§≤‡§æ‡§ú: {scan_result.get('treatment', '')}\n"
                if scan_result.get('weather_warning'):
                    context += f"‡§Æ‡•å‡§∏‡§Æ ‡§ö‡•á‡§§‡§æ‡§µ‡§®‡•Ä: {scan_result.get('weather_warning')}\n"
            
            # Create contextual prompt
            prompt = f"""{context}
‡§ï‡§ø‡§∏‡§æ‡§® ‡§ï‡§æ ‡§∏‡§µ‡§æ‡§≤: {query}

‡§ä‡§™‡§∞ ‡§¶‡•Ä ‡§ó‡§à ‡§™‡•å‡§ß‡•á ‡§ï‡•Ä ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ ‡§î‡§∞ ‡§á‡§≤‡§æ‡§ú ‡§ï‡•á ‡§Ü‡§ß‡§æ‡§∞ ‡§™‡§∞ ‡§ï‡§ø‡§∏‡§æ‡§® ‡§ï‡•á ‡§∏‡§µ‡§æ‡§≤ ‡§ï‡§æ ‡§ú‡§µ‡§æ‡§¨ ‡§¶‡•á‡§Ç‡•§ ‡§∏‡§ø‡§∞‡•ç‡§´ ‡§π‡§ø‡§Ç‡§¶‡•Ä ‡§Æ‡•á‡§Ç 2-3 ‡§µ‡§æ‡§ï‡•ç‡§Ø‡•ã‡§Ç ‡§Æ‡•á‡§Ç ‡§µ‡•ç‡§Ø‡§æ‡§µ‡§π‡§æ‡§∞‡§ø‡§ï ‡§∏‡§≤‡§æ‡§π ‡§¶‡•á‡§Ç‡•§"""
            
            data = {
                "contents": [{"parts": [{"text": prompt}]}],
                "generationConfig": {"temperature": 0.7, "maxOutputTokens": 150}
            }
            
            response = requests.post(url, json=data, headers=headers, timeout=15)
            
            if response.status_code == 200:
                result = response.json()
                if 'candidates' in result and len(result['candidates']) > 0:
                    return result['candidates'][0]['content']['parts'][0]['text'].strip()
            
            raise Exception("No response from AI")
            
        except Exception as fallback_error:
            logger.error(f"Fallback contextual query error: {str(fallback_error)}")
            return "‡§á‡§∏ ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ ‡§ï‡•á ‡§¨‡§æ‡§∞‡•á ‡§Æ‡•á‡§Ç ‡§Ö‡§ß‡§ø‡§ï ‡§ú‡§æ‡§®‡§ï‡§æ‡§∞‡•Ä ‡§ï‡•á ‡§≤‡§ø‡§è ‡§∏‡•ç‡§•‡§æ‡§®‡•Ä‡§Ø ‡§ï‡•É‡§∑‡§ø ‡§µ‡§ø‡§∂‡•á‡§∑‡§ú‡•ç‡§û ‡§∏‡•á ‡§∏‡§Ç‡§™‡§∞‡•ç‡§ï ‡§ï‡§∞‡•á‡§Ç‡•§"

def process_voice_query(query, language, user_crops, pin_code, weather_data=None, market_data=None):
    """Enhanced voice query processing with comprehensive context"""
    
    try:
        from services.enhanced_voice_assistant import enhanced_voice_assistant
        
        # Use enhanced voice assistant for better responses
        response = enhanced_voice_assistant.process_contextual_query(
            query=query,
            language=language,
            user_crops=user_crops,
            pin_code=pin_code,
            scan_result=None,
            weather_data=weather_data,
            market_data=market_data
        )
        
        return response
        
    except Exception as e:
        logger.error(f"Enhanced voice query error: {str(e)}")
        
        # Fallback to original implementation
        try:
            # Use Gemini API for chatbot
            gemini_key = os.getenv('GEMINI_API_KEY', 'AIzaSyCVchsFQ9RyH4wdM2qrVZqRBJyQ5g9qOKg')
            
            url = f"https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key={gemini_key}"
            headers = {"Content-Type": "application/json"}
            
            # Enhanced context-aware prompts for scanner results page
            query_lower = query.lower()
            
            if any(word in query_lower for word in ['often', 'frequency', '‡§ï‡§ø‡§§‡§®‡•Ä ‡§¨‡§æ‡§∞', 'how many times']):
                prompt = f"""‡§ï‡§ø‡§∏‡§æ‡§® ‡§™‡•Ç‡§õ ‡§∞‡§π‡§æ ‡§π‡•à ‡§ï‡§ø ‡§á‡§≤‡§æ‡§ú ‡§ï‡§ø‡§§‡§®‡•Ä ‡§¨‡§æ‡§∞ ‡§ï‡§∞‡§®‡§æ ‡§ö‡§æ‡§π‡§ø‡§è: {query}

‡§ú‡•à‡§µ‡§ø‡§ï ‡§â‡§™‡§ö‡§æ‡§∞ ‡§ï‡•á ‡§≤‡§ø‡§è: ‡§π‡§∞ 7-10 ‡§¶‡§ø‡§® ‡§Æ‡•á‡§Ç ‡§è‡§ï ‡§¨‡§æ‡§∞‡•§ ‡§∞‡§æ‡§∏‡§æ‡§Ø‡§®‡§ø‡§ï ‡§â‡§™‡§ö‡§æ‡§∞ ‡§ï‡•á ‡§≤‡§ø‡§è: ‡§≤‡•á‡§¨‡§≤ ‡§ï‡•á ‡§Ö‡§®‡•Å‡§∏‡§æ‡§∞, ‡§Ü‡§Æ‡§§‡•å‡§∞ ‡§™‡§∞ 10-14 ‡§¶‡§ø‡§® ‡§ï‡§æ ‡§Ö‡§Ç‡§§‡§∞‡§æ‡§≤‡•§ ‡§∏‡•Å‡§¨‡§π ‡§Ø‡§æ ‡§∂‡§æ‡§Æ ‡§ï‡§æ ‡§∏‡§Æ‡§Ø ‡§¨‡•á‡§π‡§§‡§∞ ‡§π‡•à‡•§ ‡§∏‡§ø‡§∞‡•ç‡§´ ‡§π‡§ø‡§Ç‡§¶‡•Ä ‡§Æ‡•á‡§Ç 2-3 ‡§µ‡§æ‡§ï‡•ç‡§Ø‡•ã‡§Ç ‡§Æ‡•á‡§Ç ‡§ú‡§µ‡§æ‡§¨ ‡§¶‡•á‡§Ç‡•§"""
            
            elif any(word in query_lower for word in ['neem', '‡§®‡•Ä‡§Æ', 'organic', '‡§ú‡•à‡§µ‡§ø‡§ï']):
                prompt = f"""‡§ï‡§ø‡§∏‡§æ‡§® ‡§®‡•Ä‡§Æ ‡§Ø‡§æ ‡§ú‡•à‡§µ‡§ø‡§ï ‡§â‡§™‡§ö‡§æ‡§∞ ‡§ï‡•á ‡§¨‡§æ‡§∞‡•á ‡§Æ‡•á‡§Ç ‡§™‡•Ç‡§õ ‡§∞‡§π‡§æ ‡§π‡•à: {query}

‡§®‡•Ä‡§Æ ‡§ï‡§æ ‡§§‡•á‡§≤ 10 ‡§Æ‡§ø‡§≤‡•Ä ‡§™‡•ç‡§∞‡§§‡§ø ‡§≤‡•Ä‡§ü‡§∞ ‡§™‡§æ‡§®‡•Ä ‡§Æ‡•á‡§Ç ‡§Æ‡§ø‡§≤‡§æ‡§è‡§Ç‡•§ ‡§π‡§´‡•ç‡§§‡•á ‡§Æ‡•á‡§Ç ‡§è‡§ï ‡§¨‡§æ‡§∞ ‡§õ‡§ø‡§°‡§º‡§ï‡§æ‡§µ ‡§ï‡§∞‡•á‡§Ç‡•§ ‡§Ö‡§®‡•ç‡§Ø ‡§ú‡•à‡§µ‡§ø‡§ï ‡§µ‡§ø‡§ï‡§≤‡•ç‡§™: ‡§ó‡•ã‡§¨‡§∞ ‡§ï‡§æ ‡§ò‡•ã‡§≤, ‡§π‡§≤‡•ç‡§¶‡•Ä ‡§ï‡§æ ‡§™‡•á‡§∏‡•ç‡§ü, ‡§≤‡§π‡§∏‡•Å‡§®-‡§Æ‡§ø‡§∞‡•ç‡§ö ‡§ï‡§æ ‡§ò‡•ã‡§≤‡•§ ‡§∏‡§ø‡§∞‡•ç‡§´ ‡§π‡§ø‡§Ç‡§¶‡•Ä ‡§Æ‡•á‡§Ç ‡§ú‡§µ‡§æ‡§¨ ‡§¶‡•á‡§Ç‡•§"""
            
            else:
                # General farming question
                prompt = f"""‡§Ü‡§™ ‡§è‡§ï ‡§Ö‡§®‡•Å‡§≠‡§µ‡•Ä ‡§ï‡•É‡§∑‡§ø ‡§µ‡§ø‡§∂‡•á‡§∑‡§ú‡•ç‡§û ‡§π‡•à‡§Ç‡•§ ‡§ï‡§ø‡§∏‡§æ‡§® ‡§ï‡§æ ‡§∏‡§µ‡§æ‡§≤: {query}

‡§ï‡•É‡§™‡§Ø‡§æ ‡§á‡§∏ ‡§∏‡§µ‡§æ‡§≤ ‡§ï‡§æ ‡§µ‡•ç‡§Ø‡§æ‡§µ‡§π‡§æ‡§∞‡§ø‡§ï ‡§î‡§∞ ‡§â‡§™‡§Ø‡•ã‡§ó‡•Ä ‡§ú‡§µ‡§æ‡§¨ ‡§π‡§ø‡§Ç‡§¶‡•Ä ‡§Æ‡•á‡§Ç ‡§¶‡•á‡§Ç‡•§ ‡§∏‡§∞‡§≤ ‡§≠‡§æ‡§∑‡§æ ‡§Æ‡•á‡§Ç 2-3 ‡§µ‡§æ‡§ï‡•ç‡§Ø‡•ã‡§Ç ‡§Æ‡•á‡§Ç ‡§ú‡§µ‡§æ‡§¨ ‡§¶‡•á‡§Ç ‡§ú‡•ã ‡§è‡§ï ‡§ï‡§ø‡§∏‡§æ‡§® ‡§Ü‡§∏‡§æ‡§®‡•Ä ‡§∏‡•á ‡§∏‡§Æ‡§ù ‡§∏‡§ï‡•á‡•§"""
            
            data = {
                "contents": [{
                    "parts": [{"text": prompt}]
                }],
                "generationConfig": {
                    "temperature": 0.7,
                    "maxOutputTokens": 150
                }
            }
            
            response = requests.post(url, json=data, headers=headers, timeout=15)
            
            if response.status_code == 200:
                result = response.json()
                if 'candidates' in result and len(result['candidates']) > 0:
                    ai_response = result['candidates'][0]['content']['parts'][0]['text']
                    return ai_response.strip()
                else:
                    raise Exception("No response from Gemini")
            else:
                logger.error(f"Gemini API error: {response.status_code} - {response.text}")
                raise Exception(f"Gemini API error: {response.status_code}")
                
        except Exception as fallback_error:
            logger.error(f"Fallback voice query error: {str(fallback_error)}")
            # Provide contextual fallback responses
            if any(word in query.lower() for word in ['neem', '‡§®‡•Ä‡§Æ']):
                return "‡§®‡•Ä‡§Æ ‡§ï‡§æ ‡§§‡•á‡§≤ 10 ‡§Æ‡§ø‡§≤‡•Ä ‡§™‡•ç‡§∞‡§§‡§ø ‡§≤‡•Ä‡§ü‡§∞ ‡§™‡§æ‡§®‡•Ä ‡§Æ‡•á‡§Ç ‡§Æ‡§ø‡§≤‡§æ‡§ï‡§∞ ‡§õ‡§ø‡§°‡§º‡§ï‡§æ‡§µ ‡§ï‡§∞‡•á‡§Ç‡•§ ‡§∏‡•Å‡§¨‡§π ‡§Ø‡§æ ‡§∂‡§æ‡§Æ ‡§ï‡§æ ‡§∏‡§Æ‡§Ø ‡§¨‡•á‡§π‡§§‡§∞ ‡§π‡•à‡•§"
            elif any(word in query.lower() for word in ['time', '‡§∏‡§Æ‡§Ø']):
                return "‡§∏‡•Å‡§¨‡§π 6-9 ‡§¨‡§ú‡•á ‡§Ø‡§æ ‡§∂‡§æ‡§Æ 5-7 ‡§¨‡§ú‡•á ‡§õ‡§ø‡§°‡§º‡§ï‡§æ‡§µ ‡§ï‡§∞‡•á‡§Ç‡•§ ‡§¶‡•ã‡§™‡§π‡§∞ ‡§ï‡•Ä ‡§ß‡•Ç‡§™ ‡§Æ‡•á‡§Ç ‡§® ‡§ï‡§∞‡•á‡§Ç‡•§"
            else:
                return "‡§ï‡•Å‡§õ ‡§§‡§ï‡§®‡•Ä‡§ï‡•Ä ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ ‡§π‡•à‡•§ ‡§ï‡•É‡§™‡§Ø‡§æ ‡§¶‡•ã‡§¨‡§æ‡§∞‡§æ ‡§ï‡•ã‡§∂‡§ø‡§∂ ‡§ï‡§∞‡•á‡§Ç ‡§Ø‡§æ ‡§∏‡•ç‡§•‡§æ‡§®‡•Ä‡§Ø ‡§ï‡•É‡§∑‡§ø ‡§µ‡§ø‡§∂‡•á‡§∑‡§ú‡•ç‡§û ‡§∏‡•á ‡§∏‡§Ç‡§™‡§∞‡•ç‡§ï ‡§ï‡§∞‡•á‡§Ç‡•§"

def get_groq_response(prompt):
    """Get response using Gemini API"""
    return process_voice_query(prompt, 'hi-IN', [], '110001')

def get_fallback_analysis():
    """Return basic plant health advice when AI fails"""
    return {
        'diagnosis': "‡§™‡•å‡§ß‡•á ‡§ï‡•Ä ‡§∏‡•ç‡§µ‡§æ‡§∏‡•ç‡§•‡•ç‡§Ø ‡§ú‡§æ‡§Ç‡§ö - ‡§¨‡•Å‡§®‡§ø‡§Ø‡§æ‡§¶‡•Ä ‡§µ‡§ø‡§∂‡•ç‡§≤‡•á‡§∑‡§£ (Plant Health Check - Basic Analysis)",
        'treatment': """üåø **‡§ú‡•à‡§µ‡§ø‡§ï ‡§¶‡•á‡§ñ‡§≠‡§æ‡§≤ (Organic Care):**
‚Ä¢ ‡§®‡•Ä‡§Æ ‡§ï‡§æ ‡§§‡•á‡§≤ (10 ‡§Æ‡§ø‡§≤‡•Ä ‡§™‡•ç‡§∞‡§§‡§ø ‡§≤‡•Ä‡§ü‡§∞ ‡§™‡§æ‡§®‡•Ä) - ‡§∏‡§æ‡§™‡•ç‡§§‡§æ‡§π‡§ø‡§ï ‡§õ‡§ø‡§°‡§º‡§ï‡§æ‡§µ
‚Ä¢ ‡§™‡•Ä‡§≤‡•á, ‡§ß‡§¨‡•ç‡§¨‡•á‡§¶‡§æ‡§∞, ‡§Ø‡§æ ‡§Æ‡•Å‡§∞‡§ù‡§æ‡§®‡•á ‡§µ‡§æ‡§≤‡•á ‡§™‡§§‡•ç‡§§‡•ã‡§Ç ‡§ï‡•Ä ‡§ú‡§æ‡§Ç‡§ö ‡§ï‡§∞‡•á‡§Ç
‚Ä¢ ‡§â‡§ö‡§ø‡§§ ‡§™‡§æ‡§®‡•Ä ‡§¶‡•á‡§Ç - ‡§Æ‡§ø‡§ü‡•ç‡§ü‡•Ä ‡§®‡§Æ ‡§π‡•ã ‡§≤‡•á‡§ï‡§ø‡§® ‡§ú‡§≤‡§≠‡§∞‡§æ‡§µ ‡§® ‡§π‡•ã
‚Ä¢ ‡§Æ‡§∞‡•á ‡§Ø‡§æ ‡§∞‡•ã‡§ó‡§ó‡•ç‡§∞‡§∏‡•ç‡§§ ‡§≠‡§æ‡§ó‡•ã‡§Ç ‡§ï‡•ã ‡§§‡•Å‡§∞‡§Ç‡§§ ‡§π‡§ü‡§æ ‡§¶‡•á‡§Ç

üíä **‡§∞‡§æ‡§∏‡§æ‡§Ø‡§®‡§ø‡§ï ‡§µ‡§ø‡§ï‡§≤‡•ç‡§™ (Chemical Options):**
‚Ä¢ ‡§ï‡•â‡§™‡§∞ ‡§∏‡§≤‡•ç‡§´‡•á‡§ü ‡§ò‡•ã‡§≤ (2 ‡§ó‡•ç‡§∞‡§æ‡§Æ ‡§™‡•ç‡§∞‡§§‡§ø ‡§≤‡•Ä‡§ü‡§∞) ‡§´‡§Ç‡§ó‡§≤ ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ‡§ì‡§Ç ‡§ï‡•á ‡§≤‡§ø‡§è
‚Ä¢ ‡§∏‡•ç‡§•‡§æ‡§®‡•Ä‡§Ø ‡§ï‡•É‡§∑‡§ø ‡§µ‡§ø‡§∏‡•ç‡§§‡§æ‡§∞ ‡§Ö‡§ß‡§ø‡§ï‡§æ‡§∞‡•Ä ‡§∏‡•á ‡§∏‡§Ç‡§™‡§∞‡•ç‡§ï ‡§ï‡§∞‡•á‡§Ç

üõ°Ô∏è **‡§∞‡•ã‡§ï‡§•‡§æ‡§Æ (Prevention):**
‚Ä¢ ‡§Æ‡§ø‡§ü‡•ç‡§ü‡•Ä ‡§ï‡•á ‡§∏‡•ç‡§§‡§∞ ‡§™‡§∞ ‡§™‡§æ‡§®‡•Ä ‡§¶‡•á‡§Ç, ‡§™‡§§‡•ç‡§§‡§ø‡§Ø‡•ã‡§Ç ‡§ï‡•ã ‡§ó‡•Ä‡§≤‡§æ ‡§ï‡§∞‡§®‡•á ‡§∏‡•á ‡§¨‡§ö‡•á‡§Ç
‚Ä¢ ‡§™‡•å‡§ß‡•ã‡§Ç ‡§ï‡•á ‡§Ü‡§∏‡§™‡§æ‡§∏ ‡§Ö‡§ö‡•ç‡§õ‡§æ ‡§π‡§µ‡§æ ‡§™‡•ç‡§∞‡§µ‡§æ‡§π ‡§∏‡•Å‡§®‡§ø‡§∂‡•ç‡§ö‡§ø‡§§ ‡§ï‡§∞‡•á‡§Ç
‚Ä¢ ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ ‡§ï‡•Ä ‡§∂‡•Å‡§∞‡•Å‡§Ü‡§§‡•Ä ‡§™‡§π‡§ö‡§æ‡§® ‡§ï‡•á ‡§≤‡§ø‡§è ‡§®‡§ø‡§Ø‡§Æ‡§ø‡§§ ‡§ú‡§æ‡§Ç‡§ö ‡§ï‡§∞‡•á‡§Ç

üìù **‡§®‡•ã‡§ü:** ‡§∏‡§ü‡•Ä‡§ï ‡§®‡§ø‡§¶‡§æ‡§® ‡§ï‡•á ‡§≤‡§ø‡§è, ‡§ï‡•É‡§™‡§Ø‡§æ ‡§§‡§∏‡•ç‡§µ‡•Ä‡§∞ ‡§¶‡•ã‡§¨‡§æ‡§∞‡§æ ‡§Ö‡§™‡§≤‡•ã‡§° ‡§ï‡§∞‡•á‡§Ç ‡§Ø‡§æ ‡§∏‡•ç‡§•‡§æ‡§®‡•Ä‡§Ø ‡§ï‡•É‡§∑‡§ø ‡§µ‡§ø‡§∂‡•á‡§∑‡§ú‡•ç‡§û ‡§∏‡•á ‡§∏‡§≤‡§æ‡§π ‡§≤‡•á‡§Ç‡•§""",
        'confidence': '‡§¨‡•Å‡§®‡§ø‡§Ø‡§æ‡§¶‡•Ä (Basic)',
        'model': 'Fallback Analysis'
    }

def get_ai_error():
    """Return error when AI service fails"""
    return {
        'diagnosis': "‡§è‡§Ü‡§à ‡§µ‡§ø‡§∂‡•ç‡§≤‡•á‡§∑‡§£ ‡§∏‡•á‡§µ‡§æ ‡§Ö‡§®‡•Å‡§™‡§≤‡§¨‡•ç‡§ß (AI analysis service unavailable)",
        'treatment': "‡§á‡§∏ ‡§∏‡§Æ‡§Ø ‡§™‡•å‡§ß‡•á ‡§ï‡•Ä ‡§§‡§∏‡•ç‡§µ‡•Ä‡§∞ ‡§ï‡§æ ‡§µ‡§ø‡§∂‡•ç‡§≤‡•á‡§∑‡§£ ‡§®‡§π‡•Ä‡§Ç ‡§π‡•ã ‡§∏‡§ï‡§æ‡•§ ‡§ï‡•É‡§™‡§Ø‡§æ ‡§Ö‡§™‡§®‡•á ‡§á‡§Ç‡§ü‡§∞‡§®‡•á‡§ü ‡§ï‡§®‡•á‡§ï‡•ç‡§∂‡§® ‡§ï‡•Ä ‡§ú‡§æ‡§Ç‡§ö ‡§ï‡§∞‡•á‡§Ç ‡§î‡§∞ ‡§¨‡§æ‡§¶ ‡§Æ‡•á‡§Ç ‡§™‡•Å‡§®: ‡§™‡•ç‡§∞‡§Ø‡§æ‡§∏ ‡§ï‡§∞‡•á‡§Ç‡•§",
        'error': 'AI service temporarily unavailable. Please try again later.'
    }